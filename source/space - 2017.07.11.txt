/**
	2017, June 8th - 19:20
	Version 0.0.1

	N-BODY SIMULATION

**/

#include <iostream>
#include <iomanip>
#include <string>
#include <cmath>

using namespace std;

//UNIVERSAL GRAVITATIONAL CONSTANT
const double UGC = 6.67384*pow(10.0, -11.0);

//UNIVERSAL TIME SCALE (seconds?)
double UTS = 1;

//class Particle;

class Particle {
private:

	string name;

	double mass;
	double radius;

	double position[3];
	double velocity[3];
	double acceleration[3];		// Accleration acting on particle.

	//double density;
	//double surfaceGravity;	
	//double gravitation[3];	// Acceleration particle acts on other particles.

public:

	void setName(string);
	string getName(){ return name; };

	void setMass(double);
	double getMass() { return mass; };
	void setRadius(double);
	double getRadius(){ return radius; };

	void setPosition(double, double, double);
	double getPosIndex(int index) { return position[index]; };
	double* positionVector();

	void setVelocity(double, double, double);
	double getVelIndex(int index) { return velocity[index]; };
	double* velocityVector();

	void setAcceleration(double, double, double);
	double getAccIndex(int index) { return acceleration[index]; };
	double* accelerationVector();

	void characteristics();

	//Particle();
	//Particle(string objName, double objMass, double objRadius);
	//~Particle();

};

void Particle::setName(string objName){

	name = objName;
}

void Particle::setMass(double objMass){

	mass = objMass;
}

void Particle::setRadius(double objRadius){

	radius = objRadius;
}

void Particle::setPosition(double objPosX, double objPosY, double objPosZ){

	position[0] = objPosX;
	position[1] = objPosY; 
	position[2] = objPosZ;
}

void Particle::setVelocity(double objVelX, double objVelY, double objVelZ){

	velocity[0] = objVelX;
	velocity[1] = objVelY; 
	velocity[2] = objVelZ;
}

void Particle::setAcceleration(double objAccX, double objAccY, double objAccZ){

	acceleration[0] = objAccX;
	acceleration[1] = objAccY;
	acceleration[2] = objAccZ;
}

double* Particle::positionVector(){

	double* positionClone = new double[3];

	for(int i = 0; i < 3; i++){

		positionClone[i] = getPosIndex(i);
	}

	return positionClone;
}

double* Particle::velocityVector(){

	double* velocityClone = new double[3];

	for(int i = 0; i < 3; i++){

		velocityClone[i] = getVelIndex(i);
	}

	return velocityClone;
}

double* Particle::accelerationVector(){

	double* accelerationClone = new double[3];

	for(int i = 0; i < 3; i++){

		accelerationClone[i] = getAccIndex(i);
	}

	return accelerationClone;
}

void Particle::characteristics(){

	cout << "Name:" << right << setw(16) << getName() << endl;
	cout << "Mass:" << right << setw(16) << getMass() << " kilograms" <<endl;
	cout << "Radius:" << right << setw(14) << getRadius() << " meters" << endl;
	//cout << "Position:" << right << setw(16) << "( " << endl;
}

/*
Particle::Particle(){

	cout << "Particle class CONSTRUCTOR has been called." << endl;
}

Particle::~Particle(){

	cout << "Particle class DESTRUCTOR has been called." << endl;
}
*/

void calculateAcceleration(Particle entity1, Particle entity2, int precise = 0){
	// Calculates the acceleration acting on entity1, generated by entity2

	double radialNorm = pow((pow(entity2.getPosIndex(0) - entity1.getPosIndex(0), 2.0) + 
							 pow(entity2.getPosIndex(1) - entity1.getPosIndex(1), 2.0) + 
							 pow(entity2.getPosIndex(2) - entity1.getPosIndex(2), 2.0)), 0.5);

	double gravitation = UGC*entity2.getMass()/pow(radialNorm, 3.0);
	
	if(precise != 0){
	    
	    cout << setprecision(precise) << fixed << endl;
	}
	
	//entity1.setAcceleration(
	cout << entity1.getAccIndex(0) + gravitation*(entity2.getPosIndex(0) - entity1.getPosIndex(0)) << endl;
	cout << entity1.getAccIndex(1) + gravitation*(entity2.getPosIndex(1) - entity1.getPosIndex(1)) << endl;
	cout << entity1.getAccIndex(2) + gravitation*(entity2.getPosIndex(2) - entity1.getPosIndex(2)) << endl;

	//cout << radialNorm << "\t" << gravitation << endl;
}


int main(void){

	Particle entity[2];

	cout << endl;

	entity[0].setName("Earth");
	entity[0].setMass(5.974*pow(10.0, 24.0));
	entity[0].setRadius(6.378*pow(10.0, 6.0));
	entity[0].setPosition(0,0,0);
	entity[0].setVelocity(0,0,0);
	entity[0].setAcceleration(0,0,0);
	//entity[0].characteristics();

	/*
	double * thing = entity[0].positionVector();
	cout << thing[0] << endl;
	cout << thing[1] << endl;
	cout << thing[2] << endl;
	*/

	//cout << endl;

	entity[1].setName("Luna");
	entity[1].setMass(7.342*pow(10.0, 22.0));
	entity[1].setRadius(1.7371*pow(10.0, 6.0));
	entity[1].setPosition(3.828502*pow(10.0, 8.0), 0, 3.447158*pow(10.0, 7.0));    // R = 3.84399*10^8 m
	entity[1].setVelocity(0, 1.022*pow(10.0, 3.0), 0);
	entity[1].setAcceleration(0,0,0);
	//entity[1].characteristics();

	//cout << endl;

	//calculateAcceleration(entity[1], entity[0]);		// Acceleration Earth exerts on Moon
	//calculateAcceleration(entity[0], entity[1]);		// Acceleration Moon exerts on Earth

	/*
	double* earthAcc = entity[0].accelerationVector();

	for(int i = 0; i < 3; i++){

		cout << earthAcc[i] << endl;
	}

	calculateAcceleration(entity[0], entity[1]);
	earthAcc = entity[0].accelerationVector();
	
	for(int i = 0; i < 3; i++){

		cout << earthAcc[i] << endl;
	}
	*/

	calculateAcceleration(entity[0], entity[1]);
	cout << endl;
	calculateAcceleration(entity[1], entity[0]);
	
	
	int timer = 0;
	while (timer < (60*60*24*30)){
	    if ((timer % 3600) == 0){
	        
	    }
	    
	    timer += 1;
	}


	system("pause");
	return 0;
}